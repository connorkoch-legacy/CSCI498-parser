from copy import deepcopy

import grammar  #need the CFG's production rules, so need to use this unless there's a better way

# holds one production rule with a marker. Item sets are just sets of items
class Item:
    def __init__(self, lhs, symbols, marker_index=0):
        self.lhs = lhs
        self.symbols = symbols
        self.marker = marker_index  # the symbols index right after the marker. So for say a.bc, marker would be 1

    def __hash__(self): #to create a set of items
        return hash((self.lhs, tuple(self.symbols), self.marker))

    def __eq__(self, other):    #to check if an item is in a list of items
        return self.lhs == other.lhs and self.symbols == other.symbols and self.marker == other.marker

"""
I: an item set of the grammar G
returns an item set of G, which may be the same as I
"""
def closure(I):
    C = list(deepcopy(I))   #create a copy, and convert the set to a list so we can append to the list while looping through it
    C_change_flag = True
    while C_change_flag:    #while C keeps getting changed
        C_change_flag = False
        for item in C:
            if item.symbols[item.marker].isupper(): #if the symbol to the right of the marker is a non-terminal
                new_item = Item(item.symbols[item.marker], item.symbols)
                if new_item not in C:
                    C.append(new_item)
                    C_change_flag = True

    return set(C)


"""
I: an item set of the grammar G
X: is a symbol of the grammar: in N or in Î£ or is $
returns an item set generated by the items in I progressed past X, which may be the same as I
"""
def go_to(I, X):
    K = set()
    for k in I:
        if k.symbols[k.marker] == X:
            K.add(k)

    for k in K:
        k.marker += 1

    return closure(K)


def main():
    """
    For testing purposes
    CFG in closure-test.cfg:
                Z -> S
                S -> AA
                A -> aA
                   | b
    """
    cfg = cfg.parse_input_file()    #with command line arg "closure-test.cfg"
    item_1 = Item("Z", "S")
    item_2 = Item("S", "AA")
    item_3 = Item("A", "aA")
    item_4 = Item("A", "b")


    s = {item_1}
    new_item_set = closure(s)
    for item in new_item_set:
        print(f"{item.lhs} -> {item.symbols[:item.marker] + '.' + item.symbols[item.marker:]}")

if __name__ == "__main__":
    main()
